/**
 * Copyright 2014-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
package com.amazonaws.services.dynamodbv2.transactions;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIgnore;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBVersionAttribute;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.ConditionalCheckFailedException;
import com.amazonaws.services.dynamodbv2.model.DeleteItemRequest;
import com.amazonaws.services.dynamodbv2.model.PutItemRequest;
import com.amazonaws.services.dynamodbv2.model.ReturnValue;
import com.amazonaws.services.dynamodbv2.transactions.Transaction.IsolationLevel;
import com.amazonaws.services.dynamodbv2.transactions.exceptions.TransactionRolledBackException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class MapperTransactionsIntegrationTest extends IntegrationTest {

    @DynamoDBTable(tableName = HASH_TABLE_NAME)
    public static class ExampleHashKeyItem {
        private String id;
        private String something;
        private Set<String> someSet;

        @DynamoDBHashKey(attributeName = ID_ATTRIBUTE)
        @DynamoDBAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDBAttribute
        public String getSomething() {
            return something;
        }

        public void setSomething(String something) {
            this.something = something;
        }

        @DynamoDBAttribute
        public Set<String> getSomeSet() {
            return someSet;
        }

        public void setSomeSet(Set<String> someSet) {
            this.someSet = someSet;
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getKey() {
            return Collections.singletonMap(ID_ATTRIBUTE, new AttributeValue().withS(getId()));
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getExpectedValues() {
            Map<String, AttributeValue> expected = new HashMap<String, AttributeValue>();
            expected.put("something", new AttributeValue().withS(getSomething()));
            if (getSomeSet() != null) {
                // we need to sort the values, because AttributeValue internally
                // copies our set to an ordered list
                ArrayList<String> valuesList = new ArrayList<String>(getSomeSet());
                Collections.sort(valuesList);
                expected.put("someSet", new AttributeValue().withSS(valuesList));
            }
            expected.putAll(getKey());
            return expected;
        }

    }

    private ExampleHashKeyItem hashItem0;


    @Before
    public void setup() {
        Transaction t = manager.newTransaction();
        hashItem0 = new ExampleHashKeyItem();
        hashItem0.setId(UUID.randomUUID().toString());
        hashItem0.setSomething("val");
        hashItem0.setSomeSet(new HashSet<String>(Arrays.asList("one", "two")));
        t.save(hashItem0);
        key0 = newKey(INTEG_HASH_TABLE_NAME);
        item0 = new HashMap<String, AttributeValue>(key0);
        item0.put("s_someattr", new AttributeValue("val"));
        item0.put("ss_otherattr", new AttributeValue().withSS("one", "two"));
        Map<String, AttributeValue> putResult = t.putItem(new PutItemRequest()
            .withTableName(INTEG_HASH_TABLE_NAME)
            .withItem(item0)
            .withReturnValues(ReturnValue.ALL_OLD)).getAttributes();
        assertNull(putResult);
        t.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, key0, item0, true);
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, hashItem0.getKey(), hashItem0.getExpectedValues(), true);
    }

    @After
    public void teardown() {
        Transaction t = manager.newTransaction();
        t.deleteItem(new DeleteItemRequest().withTableName(INTEG_HASH_TABLE_NAME).withKey(key0));
        t.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, key0, false);
    }

    private ExampleHashKeyItem newItem() {
        ExampleHashKeyItem item1 = new ExampleHashKeyItem();
        item1.setId(UUID.randomUUID().toString());
        return item1;
    }

    public MapperTransactionsIntegrationTest() throws IOException {
        super(new DynamoDBMapperConfig(
            DynamoDBMapperConfig.TableNameOverride.withTableNamePrefix(TABLE_NAME_PREFIX + "_")));
    }

    @Test
    public void phantomItemFromDelete() {
        ExampleHashKeyItem item1 = newItem();
        Transaction transaction = manager.newTransaction();
        transaction.delete(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), transaction.getId(), true, false);
        transaction.rollback();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), false);
        transaction.delete(Long.MAX_VALUE);
    }

    /*
     * GetItem tests
     */

    @Test
    public void lockItem() {
        ExampleHashKeyItem item1 = newItem();

        Transaction t1 = manager.newTransaction();
        Transaction t2 = manager.newTransaction();

        ExampleHashKeyItem loadedItem = t1.load(item1);

        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, false); // we're not applying locks
        assertNull(loadedItem);

        t2.delete(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t2.getId(), true, false); // we're not applying deletes either

        t2.commit();

        try {
            t1.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), false);
    }

    @Test
    public void lock2Items() {
        ExampleHashKeyItem item1 = newItem();
        ExampleHashKeyItem item2 = newItem();

        Transaction t0 = manager.newTransaction();
        item1.setSomething("val");
        t0.save(item1);

        t0.commit();

        Transaction t1 = manager.newTransaction();

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), t1.getId(), false, false);
        assertEquals(item1.getExpectedValues(), loadedItem1.getExpectedValues());

        ExampleHashKeyItem loadedItem2 = t1.load(item2);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), t1.getId(), false, false);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item2.getKey(), t1.getId(), true, false);
        assertNull(loadedItem2);

        t1.commit();
        t1.delete(Long.MAX_VALUE);

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), true);
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item2.getKey(), false);
    }

    @Test
    public void getItemWithDelete() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem loadedItem1 = t1.load(hashItem0);
        assertEquals(hashItem0.getExpectedValues(), loadedItem1.getExpectedValues());
        assertItemLocked(INTEG_HASH_TABLE_NAME, hashItem0.getKey(), loadedItem1.getExpectedValues(), t1.getId(), false, false);

        t1.delete(hashItem0);
        assertItemLocked(INTEG_HASH_TABLE_NAME, hashItem0.getKey(), hashItem0.getExpectedValues(), t1.getId(), false, false);

        ExampleHashKeyItem loadedItem2 = t1.load(hashItem0);
        assertNull(loadedItem2);
        assertItemLocked(INTEG_HASH_TABLE_NAME, hashItem0.getKey(), hashItem0.getExpectedValues(), t1.getId(), false, false);

        t1.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, hashItem0.getKey(), false);
    }

    @Test
    public void getItemNotExists() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem item1 = newItem();

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertNull(loadedItem1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, false);

        ExampleHashKeyItem loadedItem2 = t1.load(item1);
        assertNull(loadedItem2);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, false);

        t1.commit();

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), false);
    }

    @Test
    public void getItemAfterPutItemInsert() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("wef");

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertNull(loadedItem1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, false);

        t1.save(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem2 = t1.load(item1);
        assertEquals(item1.getExpectedValues(), loadedItem2.getExpectedValues());
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        t1.commit();

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), true);
    }

    /*
     * Transaction isolation and error tests
     */

    @Test
    public void conflictingWrites() {
        ExampleHashKeyItem item1 = newItem();
        Transaction t1 = manager.newTransaction();
        Transaction t2 = manager.newTransaction();
        Transaction t3 = manager.newTransaction();

        // Finish t1
        ExampleHashKeyItem t1Item = new ExampleHashKeyItem();
        t1Item.setId(item1.getId());
        t1Item.setSomething("t1");

        t1.save(t1Item);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1Item.getExpectedValues(), t1.getId(), true, true);

        t1.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1Item.getExpectedValues(), true);

        // Begin t2
        ExampleHashKeyItem t2Item = new ExampleHashKeyItem();
        t2Item.setId(item1.getId());
        t2Item.setSomething("t2");
        t2Item.setSomeSet(Collections.singleton("extra"));

        t2.save(t2Item);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t2Item.getExpectedValues(), t2.getId(), false, true);

        // Begin and finish t3
        ExampleHashKeyItem t3Item = new ExampleHashKeyItem();
        t3Item.setId(item1.getId());
        t3Item.setSomething("t3");
        t3Item.setSomeSet(Collections.singleton("things"));

        t3.save(t3Item);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t3Item.getExpectedValues(), t3.getId(), false, true);

        t3.commit();

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t3Item.getExpectedValues(), true);

        // Ensure t2 rolled back
        try {
            t2.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t3Item.getExpectedValues(), true);
    }

    @DynamoDBTable(tableName = HASH_TABLE_NAME)
    public static class ExampleVersionedHashKeyItem {
        private String id;
        private Long version = null;

        @DynamoDBHashKey(attributeName = ID_ATTRIBUTE)
        @DynamoDBAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDBVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getKey() {
            return Collections.singletonMap(ID_ATTRIBUTE, new AttributeValue().withS(getId()));
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getExpectedValues() {
            Map<String, AttributeValue> expected = new HashMap<String, AttributeValue>();
            expected.put("version", new AttributeValue().withN(getVersion().toString()));
            expected.putAll(getKey());
            return expected;
        }

    }

    @Test
    public void createVersionedItemWhenItemAlreadyExists() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), true);

        ExampleVersionedHashKeyItem item2 = new ExampleVersionedHashKeyItem();
        item2.setId(item1.getId());
        Transaction t2 = manager.newTransaction();
        try {
            t2.save(item2);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t2.rollback();
        }
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
    }

    @Test
    public void createVersionedItemInConflictingTransactions() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        // while the item is being created in the first transaction, create it in another transaction
        ExampleVersionedHashKeyItem item2 = new ExampleVersionedHashKeyItem();
        item2.setId(item1.getId());
        Transaction t2 = manager.newTransaction();
        t2.save(item2);
        t2.commit();

        // try to commit the original transaction
        try {
            t1.commit();
            fail();
        } catch (TransactionRolledBackException e) { }
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), item1.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
    }

    @Test
    public void deleteVersionedItemWithOutOfDateVersion() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // update the item to version 2
        Transaction t2 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t2.load(item1);
        t2.save(item2);
        t2.commit();

        // try to delete with an outdated view of the item
        Transaction t3 = manager.newTransaction();
        try {
            t3.delete(item1);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t3.rollback();
        }
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    @Test
    public void reusingMapperInstanceWithOutOfDateVersionThrowsOnSave() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // update the item to version 2 and save
        Transaction t2 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t2.load(item1);
        t2.save(item2);
        t2.commit();

        Transaction t3 = manager.newTransaction();
        t3.load(item1);
        try {
            t3.save(item1);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t3.rollback();
        }
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    @Test
    public void deleteVersionedItemInConflictingTransaction() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // start to delete the item
        Transaction t2 = manager.newTransaction();
        t2.delete(item1);

        // update the item to version 2
        Transaction t3 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t3.load(item1);
        t3.save(item2);
        t3.commit();

        // try to commit the delete
        try {
            t2.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    private ExampleVersionedHashKeyItem newVersionedItem() {
        ExampleVersionedHashKeyItem item1 = new ExampleVersionedHashKeyItem();
        item1.setId(UUID.randomUUID().toString());
        return item1;
    }

    @Test
    public void readCommitted() {
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("example");

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem1 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNull(loadedItem1);

        t1.commit();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), true);

        ExampleHashKeyItem loadedItem2 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNotNull(loadedItem2);
        assertEquals(item1.getExpectedValues(), loadedItem2.getExpectedValues());

        t1.delete(Long.MAX_VALUE);
    }

    @Test
    public void readUncommitted() {
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("example");

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem1 = manager.load(item1, IsolationLevel.UNCOMMITTED);
        assertNotNull(loadedItem1);
        assertEquals(item1.getExpectedValues(), loadedItem1.getExpectedValues());

        t1.rollback();
        assertItemNotLocked(INTEG_HASH_TABLE_NAME, item1.getKey(), false);

        ExampleHashKeyItem loadedItem2 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNull(loadedItem2);

        t1.delete(Long.MAX_VALUE);
    }
}
